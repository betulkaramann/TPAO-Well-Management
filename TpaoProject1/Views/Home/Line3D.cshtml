<!DOCTYPE html>
<html>
<head>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.17.0/xlsx.full.min.js"></script>
</head>
<body>
    <div id="plot"></div>
    <input type="file" id="excelFileInput" accept=".xls" />
    <input type="file" id="fileInput" accept=".json" multiple />
    <input type="file" id="jsonFileInput">
    <button id="processButton">Dosyaları İşle</button>
    <div id="plot" style="width: 900px; height: 900px;"></div>
    
    <script>
        function degreesToRadians(degrees) {
            return degrees * (Math.PI / 180);
        }

        var scatterData;
        var surfaceData;
        var flag;
        const plotDiv = document.getElementById('plot');

        document.getElementById('jsonFileInput').addEventListener('change', function (event) {
            var file = event.target.files[0];

            var reader = new FileReader();
            reader.onload = function (e) {
                var jsonData = JSON.parse(e.target.result);

                // JSON verilerini kullanma
                var wellName = jsonData.wellName;
                var depthUnit = jsonData.depthUnit;
                var wellHeadPos = jsonData.wellHeadPos;
                var pathHeader = jsonData.pathHeader;
                var path = jsonData.path;

                var iter = path.length;

                var dX = [];
                var dY = [];
                var TVD = [];

                var pointsX = [];
                var pointsY = [];

                var previousX = wellHeadPos[0];
                var previousY = wellHeadPos[1];

                for (let i = 0; i < iter; i++) {
                    dX.push(path[i][0]);
                    dY.push(path[i][1]);
                    TVD.push(path[i][2]);
                }

                for (let i = 0; i < iter; i++) {
                    pointsX.push(dX[i] + previousX);
                    pointsY.push(dY[i] + previousY);
                    previousX = pointsX[pointsX.length - 1];
                    previousY = pointsY[pointsY.length - 1];
                }

                for (let i = 1; i < TVD.length; i++) {
                    TVD[i] = TVD[i] * (-1);
                }

                scatterData2 = {
                    type: 'scatter3d',
                    mode: 'lines+markers',
                    x: pointsX,
                    y: pointsY,
                    z: TVD,
                    line: {
                        width: 6,
                        colorscale: "Viridis"
                    },
                    marker: {
                        size: 3.5,
                        colorscale: "Greens",
                        cmin: -20,
                        cmax: 50
                    }
                };
                updatePlotly();
            };
            reader.readAsText(file);
        });


        // Excel data processing
        document.getElementById('excelFileInput').addEventListener('change', function (event) {
            var file = event.target.files[0];
            var reader = new FileReader();

            reader.onload = function (e) {
                var data = new Uint8Array(e.target.result);
                var workbook = XLSX.read(data, { type: 'array' });
                var sheetName = workbook.SheetNames[0];
                var sheet = workbook.Sheets[sheetName];
                var rows = XLSX.utils.sheet_to_json(sheet);
                var md = rows.map(row => parseFloat(row['MD[m]'].replace(',', '.')));
                var inc = rows.map(row => parseFloat(row['Inc[deg]'].replace(',', '.')));
                var azi = (rows.map(row => parseFloat(row['Azi[deg]'].replace(',', '.'))));
                var tvd = rows.map(row => parseFloat(row['TVD[m]'].replace(',', '.')));

                var pointsX = [];
                var pointsY = [];
                var pointsZ = [];
                var previousX = 655000;
                var previousY = 3895000;

                for (let i = 1; i < tvd.length; i++) {
                    azi[i] = degreesToRadians(azi[i]);
                    var tempTVD = tvd[i] - tvd[i - 1];
                    var tempMd = md[i] - md[i - 1];
                    var alpha = (Math.acos(tempTVD / tempMd));

                    var t = Math.sqrt(Math.pow(tempMd, 2) - Math.pow(tempTVD, 2))
                    var y = t * Math.sin(-azi[i] + (Math.PI / 2));
                    var x = t * Math.cos(-azi[i] + (Math.PI / 2));

                    pointsX.push(x + previousX);
                    pointsY.push(y + previousY);

                    previousX = pointsX[pointsX.length - 1];
                    previousY = pointsY[pointsY.length - 1];
                }

                for (let i = 1; i < tvd.length; i++) {
                    tvd[i] = tvd[i] * (-1);
                }

                // Creating the surface trace
                scatterData = {
                    type: 'scatter3d',
                    mode: 'markers+lines',
                    x: pointsX,
                    y: pointsY,
                    z: tvd,
                    marker: {
                        size: 4,
                        color: 'green',
                        colorscale: 'Greens',
                        cmin: -20,
                        cmax: 50,
                    },
                    line: {
                        color: 'blue',
                        colorscale: 'Viridis',
                        width: 6
                    }
                };

                updatePlotly();
            };

            reader.readAsArrayBuffer(file);
        });
        var count = 0;
        var selectedFiles = 0;
        document.getElementById('processButton').addEventListener('click', function () {
            var fileInput = document.getElementById('fileInput');
            var selectedFiles = fileInput.files;
            flag= selectedFiles.length;
            for(var i = 0; i < selectedFiles.length; i++){
                var file = selectedFiles[i];
                readSurfaceJson(file);
                count++;
                

            }
            
        });

        var values = [];
        function readSurfaceJson(file){
        // JSON data processing
            var reader = new FileReader();

            reader.onload = function (event) {
                
                var jsonData = JSON.parse(event.target.result);

                const numRows = jsonData.bins[1]; 
                const numCols = jsonData.bins[0]; 
                const extent = jsonData.extent;
                const extentX = jsonData.extent[0][0];
                const extentY = jsonData.extent[0][1];
                const increment = jsonData.increment;
                const incrementX = jsonData.increment[0];
                const incrementY = jsonData.increment[1];
                
                const xValues = [];
                const yValues = [];
                const zValues = [];

                for (let i = 0; i < numCols; i++) {
                    xValues.push(extentX + incrementX * i);
                }
                for (let i = 0; i < numRows; i++) {
                    yValues.push(extentY + incrementY * i);
                }

                for (let i = 0; i < numRows; i++) {
                    const row = [];
                    for (let j = 0; j < numCols; j++) {
                        const index = i * numCols + j;
                        var elements = jsonData.points[index];
                        if (elements != null) elements = elements * (-1);
                        if (elements == null) {
                            row.push(NaN);
                        }
                        else {
                            row.push(elements);

                        }

                    }
                    zValues.push(row);
                }
                values.push({
                    x: xValues,
                    y: yValues,
                    z: zValues
                });
            };
            if (count == flag)
                updatePlotly();
            reader.readAsText(file);
        }
        

        function updatePlotly() {
            if (scatterData && scatterData2 && values.length == flag) {
                var scatterLayout = {
                    scene: {
                        aspectmode: 'manual',
                        aspectratio: {
                            x: 1,
                            y: 1,
                            z: 1
                        },
                        xaxis: {
                            autorange: 'true'
                        },
                        yaxis: {
                            autorange: 'true'
                        },
                        zaxis: {
                            autorange: 'true'
                        },

                    },
                    margin: {
                        t: 20,
                        b: 20,
                        l: 20,
                        r: 20
                    },
                    width: 900,
                    height: 600
                };


                var arrowN = {
                    type: 'cone',
                    x: [400],
                    y: [100],
                    z: [-2000],
                    u: [0],
                    v: [200],
                    w: [1],
                    colorscale: [[0, 'red'], [1, 'red']],
                    showscale: false,
                    sizemode: 'absolute',
                    anchor: 'tip',
                };
                var annotationN = {
                    x: 400,
                    y: 150,
                    z: -2000,
                    text: 'N',
                    showarrow: false,
                    font: {
                        size: 12,
                        color: 'red'
                    }
                };

                var lineLayout = {
                    title: 'Douleb',
                    scene: {
                        xaxis: { title: 'X Axis', },
                        yaxis: { title: 'Y Axis', },
                        zaxis: { title: 'Z Axis', },
                        aspectmode: 'manuel',
                        aspectratio: { x: 1, y: 1, z: 0.25 }

                    }
                };
                
                var surfaceTraces = values.map(function (surfaceData) {
                    return {
                        type: 'surface',
                        x: surfaceData.x,
                        y: surfaceData.y,
                        z: surfaceData.z,
                        colorscale: 'YlGnBu',
                        colorbar: {
                            tickvals: [-20, 50], // Renk skalası çubuğunun üzerinde görünecek değerler
                            ticktext: ['-20', '50'],
                            title: 'TVD',
                            titleside: 'right'
                        }
                    };
                });
               
                Plotly.newPlot('plot', [scatterData, scatterData2, ...surfaceTraces], scatterLayout);
                
          }  
        }

    </script>
</body>
</html>
